
//-------------------------------------------------------------------------
// Function 588
// Fichier identifié: module.h
//-------------------------------------------------------------------------


void __cdecl sub_426184(int a1, int a2, TGauge *a3)
{
  CHAR Filename[260]; // [esp+8h] [ebp-13Ch] BYREF
  _DWORD v4[4]; // [esp+10Ch] [ebp-38h] BYREF
  __int16 v5; // [esp+11Ch] [ebp-28h]
  int v6; // [esp+128h] [ebp-1Ch]
  int v7; // [esp+130h] [ebp-14h] BYREF
  int v8; // [esp+134h] [ebp-10h] BYREF
  int v9; // [esp+138h] [ebp-Ch] BYREF
  _BYTE v10[4]; // [esp+13Ch] [ebp-8h] BYREF
  _BYTE v11[4]; // [esp+140h] [ebp-4h] BYREF

  __InitExceptBlockLDTC();
  if ( *(_DWORD *)(a2 + 12) <= 0x20u )
  {
    xerror::MakeString((xerror *)v11, aPrecondition_65, aHandleHinstanc, aCBc5IncludeOwl_20, 0x3DAu);
    ++v6;
    xmsg::xmsg((xmsg *)v10, (const string *)v11);
    ++v6;
    v5 = 12;
    --v6;
    string::~string((string *)v11);
    v6 += 2;
    v6 += 3;
    _ThrowExceptionLDTC(stru_403B88, v10, 0, sub_403BE0, 1u, 0, 0, 0, v4);
  }
  GetModuleFileNameA(*(HMODULE *)(a2 + 12), Filename, 0x104u);
  v5 = 24;
  string::string((string *)&v9, aVnp);
  ++v6;
  string::string((string *)&v8, Filename);
  ++v6;
  sub_404ACF((string *)&v7, (int)&v8, (int)&v9);
  ++v6;
  sub_4253C1(a1, *(char **)(v7 + 2), a3);
  --v6;
  string::~string((string *)&v7);
  --v6;
  string::~string((string *)&v8);
  --v6;
  string::~string((string *)&v9);
}
// 403B88: using guessed type _tpidc stru_403B88[1];



//-------------------------------------------------------------------------
// Function 616
// Fichier identifié: module.h
//-------------------------------------------------------------------------


bool __cdecl sub_428154(int a1, unsigned int a2)
{
  int v3; // esi
  int v4; // edi
  bool v5; // [esp-4h] [ebp-54h]
  _DWORD v6[4]; // [esp+1Ch] [ebp-34h] BYREF
  __int16 v7; // [esp+2Ch] [ebp-24h]
  int v8; // [esp+38h] [ebp-18h]
  _BYTE v9[4]; // [esp+40h] [ebp-10h] BYREF
  _BYTE v10[4]; // [esp+44h] [ebp-Ch] BYREF
  int v11; // [esp+48h] [ebp-8h] BYREF
  int v12; // [esp+4Ch] [ebp-4h] BYREF

  __InitExceptBlockLDTC();
  if ( !(*(int (__cdecl **)(int))(*(_DWORD *)(a1 + 8) + 124))(a1) )
    return 0;
  v7 = 20;
  sub_40411C((string *)&v12, a2, *(LPCSTR *)(dword_44EC14 + 2));
  ++v8;
  v7 = 8;
  if ( *(_DWORD *)(v12 + 6) )
  {
    if ( *(_DWORD *)(a1 + 248) )
    {
      DestroyCursor(*(HCURSOR *)(a1 + 248));
      *(_DWORD *)(a1 + 248) = 0;
    }
    if ( sub_40453C((int)&v12) )
    {
      *(_DWORD *)(a1 + 248) = LoadCursorFromFileA(*(LPCSTR *)(v12 + 2));
    }
    else if ( !strnicmp(*(const char **)(*(_DWORD *)a2 + 2), aRes, 4u) )
    {
      v7 = 44;
      string::substr((string *)&v11, a2);
      ++v8;
      v3 = atol(*(const char **)(v11 + 2));
      --v8;
      string::~string((string *)&v11);
      v7 = 32;
      if ( v3 )
      {
        v4 = dword_44ECF1;
        if ( *(_DWORD *)(dword_44ECF1 + 8) <= 0x20u )
        {
          v7 = 56;
          xerror::MakeString((xerror *)v10, aPrecondition_74, aHandleHinstanc_0, aCBc5IncludeOwl_25, 0x45Cu);
          ++v8;
          xmsg::xmsg((xmsg *)v9, (const string *)v10);
          ++v8;
          v7 = 68;
          --v8;
          string::~string((string *)v10);
          v7 = 56;
          v8 += 2;
          v8 += 3;
          _ThrowExceptionLDTC(stru_403B88, v9, 0, sub_403BE0, 1u, 0, 0, 0, v6);
        }
        *(_DWORD *)(a1 + 248) = LoadCursorA(*(HINSTANCE *)(v4 + 8), (LPCSTR)(v3 + 1000));
      }
    }
    sub_433107(a1);
    v5 = *(_DWORD *)(a1 + 248) != 0;
    --v8;
    string::~string((string *)&v12);
    return v5;
  }
  else
  {
    string::~string((string *)&v12);
    return 0;
  }
}
// 403B88: using guessed type _tpidc stru_403B88[1];
// 44ECF1: using guessed type int dword_44ECF1;



//-------------------------------------------------------------------------
// Function 622
// Fichier identifié: module.h
//-------------------------------------------------------------------------


int __cdecl sub_4294C9(int a1, int a2, int a3)
{
  TModule *v4; // ecx
  int v5; // ebx
  FARPROC VNSetDLLArguments; // eax
  int v7; // ebx
  FARPROC VNCreateDLLWindow; // ebx
  int v9; // edx
  int v10; // eax
  int v11; // [esp-4h] [ebp-74h]
  _DWORD s[6]; // [esp+Ch] [ebp-64h] BYREF
  _DWORD v13[3]; // [esp+24h] [ebp-4Ch] BYREF
  _DWORD v14[4]; // [esp+30h] [ebp-40h] BYREF
  __int16 v15; // [esp+40h] [ebp-30h]
  int v16; // [esp+4Ch] [ebp-24h]
  char v17[4]; // [esp+54h] [ebp-1Ch] BYREF
  char v18[4]; // [esp+58h] [ebp-18h] BYREF
  char v19[4]; // [esp+5Ch] [ebp-14h] BYREF
  char v20[4]; // [esp+60h] [ebp-10h] BYREF
  TModule *v21; // [esp+64h] [ebp-Ch]
  int v22; // [esp+68h] [ebp-8h] BYREF

  __InitExceptBlockLDTC();
  TMsgThread::PumpWaitingMessages((TMsgThread *)(*(_DWORD *)(a1 + 104) + 25));
  v15 = 20;
  sub_40411C((string *)&v22, a2, *(LPCSTR *)(dword_44EC14 + 2));
  ++v16;
  v15 = 8;
  if ( !sub_40453C((int)&v22) )
  {
    sub_404F9C(0x73u, *(_DWORD *)(v22 + 2));
    --v16;
    string::~string((string *)&v22);
    return 0;
  }
  sub_429865(a1);
  *(_DWORD *)(a1 + 413) = sub_40768D((int)dword_44ECCE);
  v15 = 32;
  v21 = (TModule *)operator new(0x15u);
  if ( v21 )
  {
    v15 = 56;
    TModule::TModule(v21, *(const char **)(v22 + 2), 1, 1);
    v15 = 44;
    v4 = v21;
  }
  else
  {
    v4 = 0;
  }
  *(_DWORD *)(a1 + 417) = v4;
  if ( !*(_DWORD *)(a1 + 417) )
    goto LABEL_21;
  v5 = *(_DWORD *)(a1 + 417);
  if ( *(_DWORD *)(v5 + 8) <= 0x20u )
  {
    v15 = 68;
    xerror::MakeString((xerror *)v20, aPrecondition_162, aHandleHinstanc_3, aCBc5IncludeOwl_68, 0x3E3u);
    ++v16;
    xmsg::xmsg((xmsg *)v19, (const string *)v20);
    ++v16;
    v15 = 80;
    --v16;
    string::~string((string *)v20);
    v15 = 68;
    v16 += 2;
    v16 += 3;
    _ThrowExceptionLDTC(stru_403B88, v19, 0, sub_403BE0, 1u, 0, 0, 0, v14);
  }
  VNSetDLLArguments = GetProcAddress(*(HMODULE *)(v5 + 8), aVnsetdllargume);
  if ( VNSetDLLArguments )
    ((void (__stdcall *)(_DWORD))VNSetDLLArguments)(*(_DWORD *)(*(_DWORD *)a3 + 2));
  v7 = *(_DWORD *)(a1 + 417);
  if ( *(_DWORD *)(v7 + 8) <= 0x20u )
  {
    v15 = 92;
    xerror::MakeString((xerror *)v18, aPrecondition_163, aHandleHinstanc_4, aCBc5IncludeOwl_69, 0x3E3u);
    ++v16;
    xmsg::xmsg((xmsg *)v17, (const string *)v18);
    ++v16;
    v15 = 104;
    --v16;
    string::~string((string *)v18);
    v15 = 92;
    v16 += 2;
    v16 += 3;
    _ThrowExceptionLDTC(stru_403B88, v17, 0, sub_403BE0, 1u, 0, 0, 0, v14);
  }
  VNCreateDLLWindow = GetProcAddress(*(HMODULE *)(v7 + 8), aVncreatedllwin);
  if ( !VNCreateDLLWindow )
  {
    sub_404F9C(0x74u, *(_DWORD *)(v22 + 2));
LABEL_21:
    v15 = 8;
    sub_429865(a1);
    --v16;
    string::~string((string *)&v22);
    return 0;
  }
  sub_433569(v13, a1);
  v15 = 32;
  memset(s, 0, sizeof(s));
  s[0] = 24;
  s[1] = *(_DWORD *)(*(_DWORD *)(a1 + 104) + 12);
  s[2] = *(_DWORD *)(a1 + 12);
  if ( *(_DWORD *)(a1 + 134) )
    v9 = **(_DWORD **)(a1 + 134);
  else
    v9 = 0;
  s[3] = v9;
  s[4] = dword_4437A0;
  s[5] = dword_4437A4;
  v10 = ((int (__stdcall *)(_DWORD, _DWORD, _DWORD, int, _DWORD *))VNCreateDLLWindow)(
          *(_DWORD *)(a1 + 12),
          v13[0],
          v13[1],
          a1 + 413,
          s);
  if ( v10 )
    v10 = sub_405FE2(dword_44ECCE, *(char **)(a1 + 413));
  LOBYTE(v10) = 1;
  v11 = v10;
  --v16;
  string::~string((string *)&v22);
  return v11;
}
// 403B88: using guessed type _tpidc stru_403B88[1];
// 4437A0: using guessed type int dword_4437A0;
// 4437A4: using guessed type int dword_4437A4;
// 44ECCE: using guessed type int dword_44ECCE[8];



//-------------------------------------------------------------------------
// Function 623
// Fichier identifié: module.h
//-------------------------------------------------------------------------


void __cdecl sub_429865(int a1)
{
  int v1; // esi
  FARPROC VNDestroyDLLWindow; // eax
  _DWORD v3[4]; // [esp+8h] [ebp-30h] BYREF
  __int16 v4; // [esp+18h] [ebp-20h]
  int v5; // [esp+24h] [ebp-14h]
  void (__cdecl ***v6)(_DWORD, int); // [esp+2Ch] [ebp-Ch]
  _BYTE v7[4]; // [esp+30h] [ebp-8h] BYREF
  _BYTE v8[4]; // [esp+34h] [ebp-4h] BYREF

  __InitExceptBlockLDTC();
  TMsgThread::PumpWaitingMessages((TMsgThread *)(*(_DWORD *)(a1 + 104) + 25));
  if ( *(_DWORD *)(a1 + 417) )
  {
    v1 = *(_DWORD *)(a1 + 417);
    if ( *(_DWORD *)(v1 + 8) <= 0x20u )
    {
      xerror::MakeString((xerror *)v8, aPrecondition_84, aHandleHinstanc_1, aCBc5IncludeOwl_34, 0x3E3u);
      ++v5;
      xmsg::xmsg((xmsg *)v7, (const string *)v8);
      ++v5;
      v4 = 12;
      --v5;
      string::~string((string *)v8);
      v5 += 2;
      v5 += 3;
      _ThrowExceptionLDTC(stru_403B88, v7, 0, sub_403BE0, 1u, 0, 0, 0, v3);
    }
    VNDestroyDLLWindow = GetProcAddress(*(HMODULE *)(v1 + 8), aVndestroydllwi);
    if ( VNDestroyDLLWindow && ((int (__stdcall *)(_DWORD))VNDestroyDLLWindow)(0) )
      sub_405FE2(dword_44ECCE, *(char **)(a1 + 413));
    v6 = *(void (__cdecl ****)(_DWORD, int))(a1 + 417);
    if ( v6 )
    {
      v4 = 36;
      (**v6)(v6, 3);
      v4 = 24;
    }
    *(_DWORD *)(a1 + 417) = 0;
  }
  if ( *(_DWORD *)(a1 + 413) )
    sub_407C8B((void **)(a1 + 413));
}
// 403B88: using guessed type _tpidc stru_403B88[1];
// 44ECCE: using guessed type int dword_44ECCE[8];



//-------------------------------------------------------------------------
// Function 821
// Fichier identifié: module.h
//-------------------------------------------------------------------------


int __cdecl sub_4370B8(int a1, int a2)
{
  DWORD FileVersionInfoSizeA; // eax
  DWORD v3; // ebx
  CHAR Filename[256]; // [esp+4h] [ebp-138h] BYREF
  unsigned int puLen; // [esp+104h] [ebp-38h] BYREF
  DWORD dwHandle; // [esp+108h] [ebp-34h] BYREF
  _DWORD v8[4]; // [esp+10Ch] [ebp-30h] BYREF
  __int16 v9; // [esp+11Ch] [ebp-20h]
  int v10; // [esp+128h] [ebp-14h]
  _BYTE v11[4]; // [esp+130h] [ebp-Ch] BYREF
  _BYTE v12[4]; // [esp+134h] [ebp-8h] BYREF
  char *dest; // [esp+138h] [ebp-4h]

  __InitExceptBlockLDTC();
  *(_DWORD *)a1 = &off_44D984;
  dest = (char *)operator new[](0xFFu);
  ++v10;
  v9 = 20;
  *(_DWORD *)(a1 + 8) = 0;
  if ( *(_DWORD *)(a2 + 8) <= 0x20u )
  {
    v9 = 44;
    xerror::MakeString((xerror *)v12, aPrecondition_129, aHandleHinstanc_2, aCBc5IncludeOwl_59, 0x3DAu);
    ++v10;
    xmsg::xmsg((xmsg *)v11, (const string *)v12);
    ++v10;
    v9 = 56;
    --v10;
    string::~string((string *)v12);
    v9 = 44;
    v10 += 2;
    v10 += 3;
    _ThrowExceptionLDTC(stru_403B88, v11, 0, sub_403BE0, 1u, 0, 0, 0, v8);
  }
  GetModuleFileNameA(*(HMODULE *)(a2 + 8), Filename, 0xFFu);
  OemToCharA(Filename, Filename);
  FileVersionInfoSizeA = GetFileVersionInfoSizeA(Filename, &dwHandle);
  v3 = FileVersionInfoSizeA;
  v9 = 20;
  if ( FileVersionInfoSizeA )
  {
    *(_DWORD *)(a1 + 8) = operator new[](FileVersionInfoSizeA);
    if ( GetFileVersionInfoA(Filename, dwHandle, v3, *(LPVOID *)(a1 + 8)) )
    {
      strcpy(dest, aVarfileinfoTra);
      if ( VerQueryValueA(*(const LPVOID *)(a1 + 8), dest, (LPVOID *)(a1 + 4), &puLen) )
      {
        **(_DWORD **)(a1 + 4) = (**(unsigned __int16 **)(a1 + 4) << 16)
                              | (unsigned __int16)HIWORD(**(_DWORD **)(a1 + 4));
      }
      else
      {
        operator delete[](*(void **)(a1 + 8));
        *(_DWORD *)(a1 + 8) = 0;
      }
    }
  }
  --v10;
  operator delete[](dest);
  return a1;
}
// 403B88: using guessed type _tpidc stru_403B88[1];
// 44D984: using guessed type int (__cdecl *off_44D984)(void *, char);

